R"(
    //////////////////////////////////////////
    #type vertex

)"
#include "MazeVertexCommon.mzglsl"
R"(

    //////////////////////////////////////////
    uniform mat4 u_projectionMatrix;
    uniform mat4 u_viewMatrix;
    uniform vec3 u_viewPosition;

    //////////////////////////////////////////
    IN vec3 a_position;
    IN vec3 a_normal;
    IN vec4 a_color;

    //////////////////////////////////////////
    OUT vec3 v_positionOS;
    OUT vec3 v_positionWS;
    OUT vec3 v_positionVS;
    OUT vec3 v_normalWS;
    OUT vec4 v_color;

    //////////////////////////////////////////
    void main()
    {
    
        int instanceId = gl_InstanceID;
    
        mat4 modelMatrix = GetModelMatrix(instanceId);

        vec4 positionOS = vec4(a_position, 1.0);
        vec4 positionWS = positionOS * modelMatrix;
        vec4 positionVS = positionWS * u_viewMatrix;
        vec4 positionCS = positionVS * u_projectionMatrix;
        
    #if (MAZE_LHCS)
        positionCS.z = -positionCS.z;
    #endif
    
        v_positionOS = positionOS.xyz;
        v_positionWS = positionWS.xyz;
        v_positionVS = positionVS.xyz;

        v_normalWS = a_normal;

        v_color = a_color;

        gl_Position = positionCS;
    }

    //////////////////////////////////////////
    #type fragment

)"
#include "MazeFragmentCommon.mzglsl"
R"(

    //////////////////////////////////////////
    uniform vec4 u_color;
    uniform vec3 u_viewPosition;

    //////////////////////////////////////////
    IN vec3 v_positionWS;
    IN vec3 v_normalWS;
    IN vec4 v_color;
    
    //////////////////////////////////////////
    layout(location=0) out vec4 out_color;

    //////////////////////////////////////////
    void main()
    {
        // float distanceToView = distance(v_positionWS, u_viewPosition);
        // float fog = 1.0 - smoothstep(10.0, 20.0, distanceToView);

        vec3 fragmentToViewDirection = normalize(u_viewPosition - v_positionWS);
        float v = abs(dot(v_normalWS, fragmentToViewDirection));
        float alpha = smoothstep(0.1, 0.4, v);

        vec4 color = v_color * u_color;
        color.a *= alpha;
        out_color = color;
    }
)"