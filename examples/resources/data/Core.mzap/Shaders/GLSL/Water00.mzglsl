//////////////////////////////////////////
// Vertex Shader
//
//////////////////////////////////////////
#type vertex

//////////////////////////////////////////
#include "Utils/PrecisionHigh.mzglsl"


//////////////////////////////////////////
uniform mat4 u_projectionMatrix;
uniform mat4 u_viewMatrix;
uniform vec3 u_viewPosition;


//////////////////////////////////////////
IN vec3 a_position;
IN vec3 a_normal;
IN vec3 a_tangent;
IN vec3 a_bitangent;
IN vec4 a_color;
IN vec2 a_texCoords0;


//////////////////////////////////////////
OUT vec3 v_positionOS;
OUT vec3 v_positionWS;
OUT vec3 v_positionVS;
OUT vec3 v_normalOS;
OUT vec3 v_normalWS;
OUT vec3 v_tangentWS;
OUT vec3 v_bitangentWS;
OUT vec3 v_viewDirWS;


//////////////////////////////////////////
#include "Utils/Core.mzglsl"


//////////////////////////////////////////
// Main
void main()
{
    
    int instanceId = gl_InstanceID;
    
    mat4 modelMatrix = GetModelMatrix(instanceId);

    vec4 positionOS = vec4(a_position, 1.0);
    vec4 positionWS = positionOS * modelMatrix;
    vec4 positionVS = positionWS * u_viewMatrix;
    vec4 positionCS = positionVS * u_projectionMatrix;
    
    vec4 normalOS = vec4(a_normal, 1.0);
    vec4 tangentOS = vec4(a_tangent, 1.0);
    vec4 bitangentOS = vec4(a_bitangent, 1.0);
    
    mat4 normalMatrix = transpose(inverse(modelMatrix));
    
    
        
#if (MAZE_LHCS)
    positionCS.z = -positionCS.z;
#endif
    
    v_positionOS = positionOS.xyz;
    v_positionWS = positionWS.xyz;
    v_positionVS = positionVS.xyz;
    
    vec3 normalWS = normalize(normalOS * normalMatrix).xyz;
        
    v_normalOS = normalOS.xyz;
    v_normalWS = normalWS.xyz;
    
    
    v_viewDirWS = u_viewPosition - v_positionWS;

    gl_Position = positionCS;
}


//////////////////////////////////////////
// Fragment Shader
//
//////////////////////////////////////////
#type fragment

//////////////////////////////////////////
#include "Utils/PrecisionHigh.mzglsl"
#include "Utils/Core.mzglsl"


//////////////////////////////////////////
uniform sampler2D u_baseMap0;
uniform sampler2D u_baseMap1;
uniform sampler2D u_baseMap2;
uniform vec4 u_color;
uniform vec3 u_viewPosition;
uniform vec4 u_mainLightColor;
uniform vec3 u_mainLightDirection;
uniform vec4 u_ambientLightColor;
uniform float u_shininess;
uniform vec4 u_specularColor;
uniform float u_height0;
uniform float u_height1;
uniform float u_height2;

// EMISSION_MAP
uniform sampler2D u_emissionMap;
uniform vec4 u_emissionColor;

// SPECULAR_MAP
uniform sampler2D u_specularMap;

// NORMAL_MAP
uniform sampler2D u_normalMap;
uniform float u_normalScale;

// BACK_LIGHT
uniform vec4 u_backLightColor;
uniform vec3 u_backLightDirection;
uniform float u_backLightBend;

// LAMBERT_THRESHOLD
uniform float u_lambertThreshold;


//////////////////////////////////////////
IN vec3 v_positionOS;
IN vec3 v_positionWS;
IN vec3 v_positionVS;
IN vec3 v_normalOS;
IN vec3 v_normalWS;
IN vec3 v_tangentWS;
IN vec3 v_bitangentWS;
IN vec4 v_color;
IN vec2 v_uv0;
IN vec2 v_uv1;
IN vec2 v_uv2;
IN vec3 v_viewDirWS;


//////////////////////////////////////////
layout(location=0) out vec4 out_color;


//////////////////////////////////////////
// Main
void main()
{
    // View direction
    vec3 fragmentToViewDirection = normalize(v_viewDirWS);

    // Normal
#if defined(NORMAL_MAP) && (NORMAL_MAP)
    vec3 normalTS = SampleNormalTS(u_normalMap, v_uv0, u_normalScale);
    mat3 tangentToWorld = mat3(v_tangentWS, v_bitangentWS, v_normalWS);
    vec3 normalWS = normalize(TransformTangentToWorld(normalTS, tangentToWorld));
#else
    vec3 normalWS = normalize(v_normalWS);
#endif
    
        
    out_color = vec4(0.0, 0.6, 1.0, 0.3);
}