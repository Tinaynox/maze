//////////////////////////////////////////
// Vertex Shader
//
//////////////////////////////////////////
#type vertex

//////////////////////////////////////////
#include "Utils/PrecisionHigh.mzglsl"


//////////////////////////////////////////
uniform mat4 u_projectionMatrix;
uniform mat4 u_viewMatrix;
uniform vec3 u_viewPosition;


//////////////////////////////////////////
IN vec3 a_position;
IN vec3 a_normal;
IN vec4 a_color;
IN vec2 a_texCoords0;


//////////////////////////////////////////
OUT vec3 v_positionOS;
OUT vec3 v_positionWS;
OUT vec3 v_positionVS;
OUT vec3 v_normalOS;
OUT vec3 v_normalWS;
OUT vec4 v_color;
OUT vec2 v_uv0;
OUT vec3 v_viewDirWS;


//////////////////////////////////////////
#include "Utils/Core.mzglsl"


//////////////////////////////////////////
// Main
void main()
{
    
    int instanceId = gl_InstanceID;
    
    mat4 modelMatrix = GetModelMatrix(instanceId);

    vec4 positionOS = vec4(a_position, 1.0);
    vec4 positionWS = positionOS * modelMatrix;
    vec4 positionVS = positionWS * u_viewMatrix;
    vec4 positionCS = positionVS * u_projectionMatrix;
    
    vec4 normalOS = vec4(a_normal, 1.0);
    vec4 normalWS = normalize(normalOS * transpose(inverse(modelMatrix)));
        
#if (MAZE_LHCS)
    positionCS.z = -positionCS.z;
#endif
    
    v_positionOS = positionOS.xyz;
    v_positionWS = positionWS.xyz;
    v_positionVS = positionVS.xyz;
    v_normalOS = normalOS.xyz;
    v_normalWS = normalWS.xyz;
    v_color = a_color;
    v_uv0 = a_texCoords0;

    v_viewDirWS = u_viewPosition - v_positionWS;

    gl_Position = positionCS;
}


//////////////////////////////////////////
// Fragment Shader
//
//////////////////////////////////////////
#type fragment

//////////////////////////////////////////
#include "Utils/PrecisionHigh.mzglsl"


//////////////////////////////////////////
uniform sampler2D u_baseMap;
uniform vec3 u_viewPosition;
uniform vec4 u_mainLightColor;
uniform vec3 u_mainLightDirection;
uniform vec4 u_ambientLightColor;
uniform float u_shininess;
uniform vec4 u_specularColor;

uniform sampler2D u_emissionMap;
uniform vec4 u_emissionColor;

//////////////////////////////////////////
uniform float u_wavesNoise;
uniform float u_dissolveProgress;
uniform float u_edgeWidth;
uniform vec4 u_edgeColor;



//////////////////////////////////////////
IN vec3 v_positionOS;
IN vec3 v_positionWS;
IN vec3 v_positionVS;
IN vec3 v_normalOS;
IN vec3 v_normalWS;
IN vec4 v_color;
IN vec2 v_uv0;
IN vec3 v_viewDirWS;


//////////////////////////////////////////
layout(location=0) out vec4 out_color;


//////////////////////////////////////////
#include "Utils/Core.mzglsl"
#include "Utils/Math.mzglsl"


//////////////////////////////////////////
float LerpInvEdgeFactor(float t)
{
    float x = (t * 2.0 - 1.0);
    float y = -(pow(abs(x), 0.75)) + 1.0;
    return y;
}
            

//////////////////////////////////////////
// Main
void main()
{
    // Dissolve
    vec2 noiseUV = v_uv0 * u_wavesNoise;
    float noiseFactor = (MazeGradientNoise(noiseUV) + 1.0) * 0.5;
    
    float dissolveFactor = noiseFactor - u_dissolveProgress;
    if (dissolveFactor < 0.0)
    {
#if (MAZE_GL_CORE_PROFILE)
        out_color = vec4(0.0, 0.0, 0.0, 0.0);
        return;
#else
        discard;
#endif
    }
    
    float invDissolveProgress = 1.0 - u_dissolveProgress;
    
    float isEdgeZone = step(noiseFactor, u_dissolveProgress + u_edgeWidth);
    float edgeL = dissolveFactor / u_edgeWidth;
    float edgeFactor = LerpInvEdgeFactor(edgeL);
    edgeFactor = edgeFactor;

    // View direction
    vec3 fragmentToViewDirection = normalize(v_viewDirWS);

    // Normal
    vec3 normalWS = normalize(v_normalWS);

    // Albedo
    vec4 albedo = texture(u_baseMap, v_uv0);
    
    // Diffuse color
    vec3 diffuseColor = albedo.rgb;
    diffuseColor.rgb *= invDissolveProgress * invDissolveProgress;
    
    // Ambient light
    vec3 ambientLightColor = u_ambientLightColor.rgb;
    
    // Main light
    vec3 mainLightDirection = u_mainLightDirection;
    vec3 fragmentToMainLightDirection = -mainLightDirection;
    vec3 mainLightColor = u_mainLightColor.rgb;
    float mainLightAttenuation = 1.0;
    
    // Lambertian
    float NdotL = dot(normalWS, fragmentToMainLightDirection);
    float lambertian = clamp(NdotL, 0.0, 1.0);
    
    // Main light final
    vec3 mainLightColorFinal = mainLightColor * mainLightAttenuation;
    
    // Half vector
    vec3 H = normalize(fragmentToMainLightDirection + fragmentToViewDirection);
    
    // Specular map
    float NdotH = dot(normalWS, H);
    float specular = pow(clamp(NdotH, 0.0, 1.0), u_shininess * 512.0);
    vec3 specularColor = u_specularColor.rgb * specular;    
    
    // Linear color
    vec3 linearColor = 
        diffuseColor * ambientLightColor +
        diffuseColor * lambertian * mainLightColorFinal +
        specularColor * mainLightColorFinal;

    // Dissolve edge
    linearColor += mix(u_edgeColor.rgb, vec3(1,1,1), edgeFactor) * isEdgeZone * 5.0;

    // Emission map
#if defined(EMISSION_MAP) && (EMISSION_MAP)
    vec3 emissionColor = u_emissionColor.rgb * MAZE_GET_TEXEL2D(u_emissionMap, v_uv0).rgb;
    linearColor += emissionColor;
#endif
    
    out_color = vec4(linearColor, albedo.a);
}